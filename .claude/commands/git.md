---
description: Git 操作ルール
---

# コミット作成

- 「コミット」を求められた場合:
  - **重要: 必ず `git status` で現在の状態を確認すること**
  - **重要: 以前の状態やメモリを信用しない — 必ずステージングエリアの現状を確認**
  1. ファイルが既にステージングされている場合:
     - **重要: ステージング済みファイルがある場合、`git add` や `git restore` を絶対に使わない**
     - **重要: ステージングエリアを一切変更しない**
     - `git diff --staged` でステージング済みファイルを確認し、そのファイル*のみ*に基づくコミットメッセージを作成
     - メッセージ付きで `git commit` を直接実行（ユーザーが適宜承認する）
     - ユーザーが既にステージングエリアを準備済み — その判断を完全に尊重すること
  2. ステージングされたファイルがない場合:
     - `git status` で差分を確認
     - 以下のコミット粒度に基づいてファイルを順次ステージングしてからコミット:
       - パッケージ単位でコミットを分割
       - 依存元を先にコミット（依存順序が不明な場合は `npx lerna list --graph` で確認）
- **各コミット後:**
  - **重要: 自動的に次のコミットに進まない**
  - **重要: 次に何をすべきか推測しない**
  - **重要: 以前の状態のメモリを信用しない**
  - `git status` と `git diff` で現在の状態を確認
  - この判定プロセスの最初に戻る（ファイルがステージングされているかどうかの確認）
  - 続行する前にユーザーの確認または新しい指示を待つ
- OS、アプリケーション設定、またはコンテキストから英語以外の言語が使用されていると判断される場合、コミットコマンド実行の直前に、コミットメッセージの翻訳と説明をその言語で提供すること。

# パッケージのコミット順序（依存元優先）

複数パッケージにまたがる変更をコミットする場合、必ず**リーフからルートへ**（依存元を依存先より先に）コミットする。

```
beholder（自己完結）
      ↑
      └── crawler ── nitpicker CLI ← roar
           ↑              ↑      ↑
           │             core   report-google-sheets
           │              ↑
           │         analyze-* プラグイン
           └── @d-zero/dealer（外部）
```

| ティア | パッケージ                                                                                                                                       |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| 0      | `beholder`, `types`, `roar`                                                                                                                      |
| 1      | `crawler`, `core`                                                                                                                                |
| 2      | `analyze-axe`, `analyze-lighthouse`, `analyze-main-contents`, `analyze-markuplint`, `analyze-search`, `analyze-textlint`, `report-google-sheets` |
| 3      | `nitpicker`（統合 CLI）                                                                                                                          |
| —      | `test-server`（E2E テスト専用、プロダクションコードには非依存）                                                                                  |

- 同一ティア内では順序不問
- ルート設定の変更（`tsconfig.json`, CI 等）はパッケージの変更より先にコミット
- 単一パッケージの変更は順序付け不要 — そのパッケージだけをコミット
- 不明な場合は `npx lerna list --graph` で確認

# コミットメッセージの形式

- 英語で記述すること
- 命令法を使用すること
- Conventional Commits を使用すること
  - 使用するタイプ:
    - `feat`
    - `fix`
    - `docs`
    - `refactor`
    - `test`
    - `chore`
  - 使用するスコープ:
    - 各パッケージ名（ネームスペースなし）: `beholder`, `crawler`, `core`, `types`, `roar`, `analyze-axe`, `analyze-lighthouse`, `analyze-main-contents`, `analyze-markuplint`, `analyze-search`, `analyze-textlint`, `report-google-sheets`, `nitpicker`
    - `repo`
    - `deps`
    - `github`
- メッセージ本文の各行は100文字以下
- 件名は sentence-case, start-case, pascal-case, upper-case にしない

# コミットメッセージの安全ガイドライン

- 破壊的変更や複雑なコミットメッセージには、必ず heredoc 形式を使用（下記参照）
- シンプルな1行コミットにはシングルクォート (') を使用
- 破壊的変更で複数の -m フラグを絶対に使わない（commitlint のパースエラーの原因になる）

## Heredoc 形式（破壊的変更では必須）

heredoc とコマンド置換を使って複数行のコミットメッセージを渡す。これにより:

- 特殊文字（感嘆符など）が正しく保持される
- 複数行メッセージが適切にフォーマットされる
- commitlint がメッセージを正しくパースできる

**形式:**

```bash
git commit -m "$(cat <<'EOF'
type(scope)!: subject line

BREAKING CHANGE: 説明

詳細:
- 変更点1
- 変更点2
EOF
)"
```

**重要な注意点:**

- `<<'EOF'`（クォート付き）で変数展開を防ぐ
- `EOF` の後に `)` で閉じてコマンド置換を完了
- 破壊的変更で複数の `-m` フラグを使用しない
- メッセージ全体を `"$(cat <<'EOF' ... EOF)"` で囲む

## シンプルなコミット（非破壊的変更）

破壊的変更のないシンプルな1行コミット:

```bash
git commit -m 'type(scope): subject line'
```

複数行の非破壊的コミットにも、適切なフォーマットを確保するため heredoc 形式を使用すること
